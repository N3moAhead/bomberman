// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.977
package matches

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import (
	"github.com/N3moAhead/bombahead/website/internal/models"
	"github.com/N3moAhead/bombahead/website/internal/templates/layout"
	"github.com/N3moAhead/bombahead/website/internal/viewmodels"
	"github.com/a-h/templ"
	templruntime "github.com/a-h/templ/runtime"
)

func Details(csrf string, user *models.User, vm *viewmodels.MatchDetail, historyJson string) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Var2 := templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
			templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
			templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
			if !templ_7745c5c3_IsBuffer {
				defer func() {
					templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
					if templ_7745c5c3_Err == nil {
						templ_7745c5c3_Err = templ_7745c5c3_BufErr
					}
				}()
			}
			ctx = templ.InitializeContext(ctx)
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<div class=\"flex justify-center p-4\"><div class=\"card w-11/12 bg-base-100 shadow-xl\"><div class=\"card-body\"><div class=\"flex justify-between items-center mb-4\"><h2 class=\"card-title text-2xl\">Game Review: ")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var3 string
			templ_7745c5c3_Var3, templ_7745c5c3_Err = templ.JoinStringErrs(vm.Match.Bot1.Name)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 15, Col: 71}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var3))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, " vs ")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var4 string
			templ_7745c5c3_Var4, templ_7745c5c3_Err = templ.JoinStringErrs(vm.Match.Bot2.Name)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 15, Col: 97}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var4))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "</h2></div><div class=\"flex flex-row gap-8\"><div class=\"flex flex-col items-center\"><canvas id=\"bomberman-canvas\" width=\"600\" height=\"600\" class=\"border border-gray-500 rounded-lg\"></canvas><div class=\"flex items-center space-x-4 mt-4\"><button id=\"prev-tick\" class=\"btn btn-primary\">Prev</button> <span id=\"tick-counter\">Tick: 0 / ")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var5 string
			templ_7745c5c3_Var5, templ_7745c5c3_Err = templ.JoinStringErrs(len(vm.History.Ticks) - 1)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 24, Col: 69}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var5))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, "</span> <button id=\"next-tick\" class=\"btn btn-primary\">Next</button></div></div><div class=\"w-1/3\"><h3 class=\"text-lg font-bold mb-2\">Moves</h3><div class=\"h-[600px] overflow-y-auto border border-gray-300 rounded-lg bg-base-200\"><table class=\"table table-sm\"><thead><tr><th>Tick</th><th>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var6 string
			templ_7745c5c3_Var6, templ_7745c5c3_Err = templ.JoinStringErrs(vm.Match.Bot1.Name)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 37, Col: 35}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var6))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 5, "</th><th>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var7 string
			templ_7745c5c3_Var7, templ_7745c5c3_Err = templ.JoinStringErrs(vm.Match.Bot2.Name)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 38, Col: 35}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var7))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 6, "</th><th>Events</th></tr></thead> <tbody id=\"move-list-tbody\"></tbody></table></div></div></div></div></div></div><input class=\"hidden\" id=\"historyData\" history-data=\"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var8 string
			templ_7745c5c3_Var8, templ_7745c5c3_Err = templ.JoinStringErrs(templ.JSONString(historyJson))
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 53, Col: 85}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var8))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 7, "\"><script>\n      const historyInput = document.getElementById(\"historyData\");\n      const history = JSON.parse(\n        JSON.parse(historyInput.getAttribute(\"history-data\")),\n      );\n\n      const bot1Name = \"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Var9, templ_7745c5c3_Err := templruntime.ScriptContentInsideStringLiteral(vm.Match.Bot1.Name)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 60, Col: 45}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ_7745c5c3_Var9)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 8, "\";\n      const bot2Name = \"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Var10, templ_7745c5c3_Err := templruntime.ScriptContentInsideStringLiteral(vm.Match.Bot2.Name)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 61, Col: 45}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ_7745c5c3_Var10)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 9, "\";\n      const playerIDToName = {\n        \"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Var11, templ_7745c5c3_Err := templruntime.ScriptContentInsideStringLiteral(vm.Match.Bot1AuthToken)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 63, Col: 34}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ_7745c5c3_Var11)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 10, "\":\"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Var12, templ_7745c5c3_Err := templruntime.ScriptContentInsideStringLiteral(vm.Match.Bot1.Name)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 63, Col: 61}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ_7745c5c3_Var12)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 11, "\",\n        \"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Var13, templ_7745c5c3_Err := templruntime.ScriptContentInsideStringLiteral(vm.Match.Bot2AuthToken)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 64, Col: 34}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ_7745c5c3_Var13)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 12, "\":\"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Var14, templ_7745c5c3_Err := templruntime.ScriptContentInsideStringLiteral(vm.Match.Bot2.Name)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 64, Col: 61}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ_7745c5c3_Var14)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 13, "\"\n      };\n\n      const canvas = document.getElementById(\"bomberman-canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      const tickCounter = document.getElementById(\"tick-counter\");\n      const prevBtn = document.getElementById(\"prev-tick\");\n      const nextBtn = document.getElementById(\"next-tick\");\n      const moveListTbody = document.getElementById(\"move-list-tbody\");\n      const textureAtlas = new Image();\n      textureAtlas.src = \"/static/images/texture_atlas.png\";\n\n      let currentTick = 0;\n      const totalTicks = history.ticks.length - 1;\n      const fieldWidth = history.initial_field.width;\n      const fieldHeight = history.initial_field.height;\n      const tileWidth = canvas.width / fieldWidth;\n      const tileHeight = canvas.height / fieldHeight;\n\n      const playerIndexMap = new Map();\n      if (history.ticks[0] && history.ticks[0].players) {\n        history.ticks[0].players.forEach((player, index) => {\n          playerIndexMap.set(player.id, index);\n        });\n      }\n\n      function populateMoveList() {\n        if (!history.ticks) return;\n\n        const bot1Id = \"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Var15, templ_7745c5c3_Err := templruntime.ScriptContentInsideStringLiteral(vm.Match.Bot1AuthToken)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 93, Col: 49}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ_7745c5c3_Var15)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 14, "\";\n        const bot2Id = \"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Var16, templ_7745c5c3_Err := templruntime.ScriptContentInsideStringLiteral(vm.Match.Bot2AuthToken)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 94, Col: 49}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ_7745c5c3_Var16)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 15, "\";\n\n        history.ticks.forEach((tick, index) => {\n          const moveEntry = document.createElement(\"tr\");\n          moveEntry.classList.add(\"hover\"); // DaisyUI class for hover effect\n          moveEntry.dataset.tick = index;\n\n          const prevTick = index > 0 ? history.ticks[index - 1] : null;\n          const moves = {};\n\n          if (tick.players) {\n            tick.players.forEach((player) => {\n              const prevPlayer = prevTick ? prevTick.players.find(p => p.id === player.id) : null;\n              let move = \"\";\n              // Check for death\n              if (prevPlayer && prevPlayer.health > 0 && player.health === 0) {\n                  move = 'ðŸ’€';\n              }\n              // If not dead, show the move\n              else if (player.move) {\n                  move = player.move;\n              }\n              moves[player.authToken] = move;\n            });\n          }\n\n          const player1Move = moves[bot1Id] || \"\";\n          const player2Move = moves[bot2Id] || \"\";\n\n          const numBombs = tick.bombs ? tick.bombs.length : 0;\n          const numExplosions = tick.explosions ? tick.explosions.length : 0;\n\n          let livesLost = 0;\n          if (index > 0) {\n            const prevTick = history.ticks[index - 1];\n            if (tick.players && prevTick.players) {\n                tick.players.forEach(currentPlayer => {\n                    const prevPlayer = prevTick.players.find(p => p.id === currentPlayer.id);\n                    if (prevPlayer && currentPlayer.health < prevPlayer.health) {\n                        livesLost += (prevPlayer.health - currentPlayer.health);\n                    }\n                });\n            }\n          }\n\n          let eventsStr = \"\";\n          if (livesLost > 0) {\n              eventsStr += `${livesLost}ðŸ’” `;\n          }\n          if (numBombs > 0) {\n              eventsStr += `${numBombs}ðŸ’£ `;\n          }\n          if (numExplosions > 0) {\n              eventsStr += `${numExplosions}ðŸ’¥`;\n          }\n\n          moveEntry.innerHTML = `\n            <th>${index}</th>\n            <td><span class=\"font-mono\">${player1Move}</span></td>\n            <td><span class=\"font-mono\">${player2Move}</span></td>\n            <td>${eventsStr}</td>\n          `;\n\n          moveEntry.addEventListener(\"click\", () => {\n            renderTick(index);\n          });\n          moveListTbody.appendChild(moveEntry);\n        });\n      }\n\n      function updateMoveHighlight(tickIndex) {\n        const moveEntries = moveListTbody.children;\n        for (let i = 0; i < moveEntries.length; i++) {\n          if (parseInt(moveEntries[i].dataset.tick) === tickIndex) {\n            moveEntries[i].classList.add(\"active\", \"outline\", \"outline-2\", \"outline-primary\");\n            moveEntries[i].scrollIntoView({ block: 'center', behavior: 'smooth' });\n          } else {\n            moveEntries[i].classList.remove(\"active\", \"outline\", \"outline-2\", \"outline-primary\");\n          }\n        }\n      }\n\n      const tileColors = {\n        AIR: \"lightgray\", // Empty\n        WALL: \"gray\", // Wall\n        BOX: \"sandybrown\", // Box\n      };\n\n      function drawField(field) {\n        for (let y = 0; y < fieldHeight; y++) {\n          for (let x = 0; x < fieldWidth; x++) {\n            const tile = field[y * fieldWidth + x];\n            const destX = x * tileWidth;\n            const destY = y * tileHeight;\n            const baseSpriteWidth = 32;\n            const baseSpriteHeight = 32;\n\n            // Always draw floor first\n            ctx.drawImage(\n              textureAtlas,\n              64, // floor sx\n              0, // floor sy\n              baseSpriteWidth,\n              baseSpriteHeight,\n              destX,\n              destY,\n              tileWidth,\n              tileHeight,\n            );\n\n            if (tile === \"WALL\") {\n              const hasWallUp =\n                y > 0 && field[(y - 1) * fieldWidth + x] === \"WALL\";\n              const hasWallDown =\n                y < fieldHeight - 1 &&\n                field[(y + 1) * fieldWidth + x] === \"WALL\";\n              const hasWallLeft =\n                x > 0 && field[y * fieldWidth + (x - 1)] === \"WALL\";\n              const hasWallRight =\n                x < fieldWidth - 1 &&\n                field[y * fieldWidth + (x + 1)] === \"WALL\";\n\n              let sx = 0;\n              const sy = 32; // Wall sprites are in the second row\n\n              // The logic to select the correct wall sprite based on neighbors.\n              // Bitmask: 8 (Up), 4 (Down), 2 (Left), 1 (Right)\n              const neighbors =\n                (hasWallUp << 3) |\n                (hasWallDown << 2) |\n                (hasWallLeft << 1) |\n                hasWallRight;\n\n              switch (neighbors) {\n                case 0: // No neighbors: solitary wall\n                  sx = 192;\n                  break;\n                case 1: // Right only\n                case 2: // Left only\n                case 3: // Left and Right: horizontal wall\n                  sx = 0;\n                  break;\n                case 4: // Down only\n                case 8: // Up only\n                case 12: // Up and Down: vertical wall\n                  sx = 32;\n                  break;\n                case 5: // Down and Right: corner â•”\n                  sx = 64;\n                  break;\n                case 6: // Down and Left: corner â•—\n                  sx = 96;\n                  break;\n                case 9: // Up and Right: corner â•š\n                  sx = 128;\n                  break;\n                case 10: // Up and Left: corner â•\n                  sx = 160;\n                  break;\n                default:\n                  // T-junctions and Crosses\n                  if (neighbors & 3) {\n                    // Has Left or Right, prioritize horizontal\n                    sx = 0;\n                  } else {\n                    // Must be a T-junction pointing left/right, use vertical\n                    sx = 32;\n                  }\n                  break;\n              }\n\n              ctx.drawImage(\n                textureAtlas,\n                sx,\n                sy,\n                baseSpriteWidth,\n                baseSpriteHeight,\n                destX,\n                destY,\n                tileWidth,\n                tileHeight,\n              );\n            } else if (tile === \"BOX\") {\n              ctx.drawImage(\n                textureAtlas,\n                32, // sx\n                0, // sy\n                baseSpriteWidth,\n                baseSpriteHeight,\n                destX,\n                destY,\n                tileWidth,\n                tileHeight,\n              );\n            }\n            // For AIR tiles, the floor is already drawn, so do nothing else.\n          }\n        }\n      }\n\n      function drawPlayers(players) {\n        const MAX_LIVES = 3;\n        const HEART_SPRITE_WIDTH = 16;\n        const HEART_SPRITE_HEIGHT = 16;\n        const FULL_HEART_SX = 96;\n        const EMPTY_HEART_SX = 112;\n        const HEARTS_SY = 0;\n        const SPRITE_WIDTH = 32;\n\n        players.forEach((player) => {\n          // Determine player state\n          let state = \"IDLE\";\n          if (player.health === 0) {\n            state = \"DEAD\";\n          } else if (currentTick > 0) {\n            const prevTick = history.ticks[currentTick - 1];\n            const prevPlayer = prevTick.players.find((p) => p.id === player.id);\n            if (prevPlayer) {\n              if (player.pos.x > prevPlayer.pos.x) state = \"RIGHT\";\n              else if (player.pos.x < prevPlayer.pos.x) state = \"LEFT\";\n              else if (player.pos.y > prevPlayer.pos.y) state = \"DOWN\";\n              else if (player.pos.y < prevPlayer.pos.y) state = \"UP\";\n            }\n          }\n\n          // Determine sprite coordinates\n          const playerIndex = playerIndexMap.get(player.id) || 0;\n          const sy = playerIndex === 0 ? 192 : 160;\n          let baseSx = 0;\n          switch (state) {\n            case \"DOWN\":\n              baseSx = 0;\n              break;\n            case \"LEFT\":\n              baseSx = 3 * SPRITE_WIDTH;\n              break;\n            case \"RIGHT\":\n              baseSx = 6 * SPRITE_WIDTH;\n              break;\n            case \"UP\":\n              baseSx = 9 * SPRITE_WIDTH;\n              break;\n            case \"DEAD\":\n              baseSx = 12 * SPRITE_WIDTH;\n              break;\n            case \"IDLE\":\n            default:\n              baseSx = 0;\n              break;\n          }\n\n          const sx =\n            state === \"IDLE\" ? baseSx : baseSx + animationFrame * SPRITE_WIDTH;\n\n          // Draw Player Sprite\n          ctx.drawImage(\n            textureAtlas,\n            sx,\n            sy,\n            SPRITE_WIDTH,\n            SPRITE_WIDTH, // Assuming square sprites\n            player.pos.x * tileWidth,\n            player.pos.y * tileHeight,\n            tileWidth,\n            tileHeight,\n          );\n\n          const lives = player.health !== undefined ? player.health : MAX_LIVES;\n          if (lives > 0) {\n            const heartRenderWidth = tileWidth / 2.5;\n            const heartRenderHeight = tileHeight / 2.5;\n            const totalHeartsWidth = MAX_LIVES * heartRenderWidth;\n            const startX =\n              player.pos.x * tileWidth + tileWidth / 2 - totalHeartsWidth / 2;\n            const startY = player.pos.y * tileHeight - heartRenderHeight * 1.1; // Place slightly above the tile\n\n            const playerName = playerIDToName[player.authToken];\n            if (playerName) {\n              ctx.fillStyle = \"#FFF\";\n              ctx.font = \"bold 10px monospace\";\n              ctx.textAlign = \"center\";\n              ctx.fillText(\n                playerName,\n                player.pos.x * tileWidth + tileWidth / 2,\n                startY + 35,\n              );\n            }\n\n            for (let i = 0; i < MAX_LIVES; i++) {\n              const isFull = i < lives;\n              const heartSx = isFull ? FULL_HEART_SX : EMPTY_HEART_SX;\n\n              ctx.drawImage(\n                textureAtlas,\n                heartSx,\n                HEARTS_SY,\n                HEART_SPRITE_WIDTH,\n                HEART_SPRITE_HEIGHT,\n                startX + i * heartRenderWidth,\n                startY,\n                heartRenderWidth,\n                heartRenderHeight,\n              );\n            }\n          }\n        });\n      }\n\n      function getPlayerById(id) {\n        // Find the player with the given id in the first tick\n        const firstTick = history.ticks[0];\n        return firstTick.players.find((p) => p.id === id);\n      }\n\n      let animationFrame = 0;\n      const FRAME_COUNT = 3;\n      const SPRITE_WIDTH = 32;\n\n      function drawBombs(bombs) {\n        const sx = animationFrame * SPRITE_WIDTH;\n        const sy = 64;\n\n        bombs.forEach((bomb) => {\n          ctx.drawImage(\n            textureAtlas,\n            sx,\n            sy,\n            SPRITE_WIDTH,\n            SPRITE_WIDTH,\n            bomb.pos.x * tileWidth,\n            bomb.pos.y * tileHeight,\n            tileWidth,\n            tileHeight,\n          );\n        });\n      }\n\n      function drawExplosions(explosions) {\n        if (!explosions || explosions.length === 0) {\n          return;\n        }\n        const explosionSet = new Set(\n          explosions.map((exp) => `${exp.x},${exp.y}`),\n        );\n\n        explosions.forEach((exp) => {\n          const hasUp = explosionSet.has(`${exp.x},${exp.y - 1}`);\n          const hasDown = explosionSet.has(`${exp.x},${exp.y + 1}`);\n          const hasLeft = explosionSet.has(`${exp.x - 1},${exp.y}`);\n          const hasRight = explosionSet.has(`${exp.x + 1},${exp.y}`);\n\n          // Bitmask: 8 (U), 4 (D), 2 (L), 1 (R)\n          const neighbors =\n            (hasUp << 3) | (hasDown << 2) | (hasLeft << 1) | hasRight;\n\n          let baseSx = 0;\n          let sy = 0;\n\n          switch (neighbors) {\n            // End-caps\n            case 1: // Right only\n              baseSx = 0;\n              sy = 13 * 32;\n              break;\n            case 2: // Left only\n              baseSx = 0;\n              sy = 11 * 32;\n              break;\n            case 4: // Down only\n              baseSx = 0;\n              sy = 10 * 32;\n              break;\n            case 8: // Up only\n              baseSx = 0;\n              sy = 12 * 32;\n              break;\n\n            // Straight pieces\n            case 3: // Left-Right\n              baseSx = 0;\n              sy = 9 * 32;\n              break;\n            case 12: // Up-Down\n              baseSx = 0;\n              sy = 8 * 32;\n              break; // Fallback to cross\n\n            // Corners\n            case 6: // Down-Left\n              baseSx = 96;\n              sy = 7 * 32;\n              break;\n            case 5: // Down-Right\n              baseSx = 96;\n              sy = 10 * 32;\n              break;\n            case 10: // Up-Left\n              baseSx = 96;\n              sy = 8 * 32;\n              break;\n            case 9: // Up-Right\n              baseSx = 96;\n              sy = 9 * 32;\n              break;\n\n            // T-Junctions\n            case 7: // Down-Left-Right\n              baseSx = 96;\n              sy = 14 * 32;\n              break;\n            case 11: // Up-Left-Right\n              baseSx = 96;\n              sy = 12 * 32;\n              break;\n            case 13: // Up-Down-Right\n              baseSx = 96;\n              sy = 13 * 32;\n              break;\n            case 14: // Up-Down-Left\n              baseSx = 96;\n              sy = 11 * 32;\n              break;\n\n            // Cross and default\n            case 15: // All directions\n            default:\n              baseSx = 0;\n              sy = 7 * 32;\n              break;\n          }\n\n          const sx = baseSx + animationFrame * SPRITE_WIDTH;\n          ctx.drawImage(\n            textureAtlas,\n            sx,\n            sy,\n            SPRITE_WIDTH,\n            SPRITE_WIDTH,\n            exp.x * tileWidth,\n            exp.y * tileHeight,\n            tileWidth,\n            tileHeight,\n          );\n        });\n      }\n\n      function drawDestroyedBoxes(boxes, field) {\n        boxes.forEach((box) => {\n          field[box.y * fieldWidth + box.x] = \" \";\n        });\n      }\n\n      function renderTick(tickIndex, isNewTick = true) {\n        if (isNewTick) {\n          currentTick = tickIndex;\n        }\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        const tick = history.ticks[tickIndex];\n        if (!tick) return;\n\n        // Rebuild field state up to the current tick\n        let field = [...history.initial_field.field];\n        for (let i = 0; i <= tickIndex; i++) {\n          const pastTick = history.ticks[i];\n          if (pastTick.destroyed_boxes) {\n            drawDestroyedBoxes(pastTick.destroyed_boxes, field);\n          }\n        }\n\n        drawField(field);\n        drawPlayers(tick.players);\n        drawBombs(tick.bombs);\n        drawExplosions(tick.explosions);\n\n        tickCounter.textContent = `Tick: ${tickIndex} / ${totalTicks}`;\n        updateMoveHighlight(tickIndex);\n      }\n\n      prevBtn.addEventListener(\"click\", () => {\n        if (currentTick > 0) {\n          renderTick(currentTick - 1);\n        }\n      });\n\n      nextBtn.addEventListener(\"click\", () => {\n        if (currentTick < totalTicks) {\n          renderTick(currentTick + 1);\n        }\n      });\n\n      let lastFrameTime = 0;\n      const ANIMATION_INTERVAL = 200; // ms per frame\n\n      function animationLoop(currentTime) {\n        const deltaTime = currentTime - lastFrameTime;\n\n        if (deltaTime > ANIMATION_INTERVAL) {\n          lastFrameTime = currentTime;\n          animationFrame = (animationFrame + 1) % FRAME_COUNT;\n          // Re-render the current tick without changing it\n          renderTick(currentTick, false);\n        }\n\n        requestAnimationFrame(animationLoop);\n      }\n\n      // Initial render\n      textureAtlas.onload = () => {\n        populateMoveList();\n        renderTick(0);\n        requestAnimationFrame(animationLoop);\n      };\n    </script>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			return nil
		})
		templ_7745c5c3_Err = layout.Base(csrf, user).Render(templ.WithChildren(ctx, templ_7745c5c3_Var2), templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
