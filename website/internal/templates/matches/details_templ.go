// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.977
package matches

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import (
	"github.com/N3moAhead/bomberman/website/internal/models"
	"github.com/N3moAhead/bomberman/website/internal/templates/layout"
	"github.com/N3moAhead/bomberman/website/internal/viewmodels"
)

func Details(csrf string, user *models.User, vm *viewmodels.MatchDetail, historyJson string) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Var2 := templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
			templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
			templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
			if !templ_7745c5c3_IsBuffer {
				defer func() {
					templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
					if templ_7745c5c3_Err == nil {
						templ_7745c5c3_Err = templ_7745c5c3_BufErr
					}
				}()
			}
			ctx = templ.InitializeContext(ctx)
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<div class=\"container mx-auto p-4\"><h1 class=\"text-2xl font-bold mb-4\">Match Review: ")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var3 string
			templ_7745c5c3_Var3, templ_7745c5c3_Err = templ.JoinStringErrs(vm.Match.MatchID)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 12, Col: 71}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var3))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "</h1><div class=\"flex flex-col items-center\"><canvas id=\"bomberman-canvas\" width=\"800\" height=\"800\" class=\"border border-gray-500\"></canvas><div class=\"flex items-center space-x-4 mt-4\"><button id=\"prev-tick\" class=\"btn btn-primary\">Prev</button> <span id=\"tick-counter\">Tick: 0 / ")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var4 string
			templ_7745c5c3_Var4, templ_7745c5c3_Err = templ.JoinStringErrs(len(vm.History.Ticks) - 1)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 17, Col: 66}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var4))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "</span> <button id=\"next-tick\" class=\"btn btn-primary\">Next</button></div></div></div><input class=\"hidden\" id=\"historyData\" history-data=\"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var5 string
			templ_7745c5c3_Var5, templ_7745c5c3_Err = templ.JoinStringErrs(templ.JSONString(historyJson))
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/templates/matches/details.templ`, Line: 22, Col: 85}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var5))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, "\"><script>\n      const historyInput = document.getElementById(\"historyData\");\n      const history = JSON.parse(\n        JSON.parse(historyInput.getAttribute(\"history-data\")),\n      );\n      console.log(typeof history);\n      const canvas = document.getElementById(\"bomberman-canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      const tickCounter = document.getElementById(\"tick-counter\");\n      const prevBtn = document.getElementById(\"prev-tick\");\n      const nextBtn = document.getElementById(\"next-tick\");\n      const textureAtlas = new Image();\n      textureAtlas.src = \"/static/images/texture_atlas.png\";\n\n      let currentTick = 0;\n      const totalTicks = history.ticks.length - 1;\n      const fieldWidth = history.initial_field.width;\n      const fieldHeight = history.initial_field.height;\n      const tileWidth = canvas.width / fieldWidth;\n      const tileHeight = canvas.height / fieldHeight;\n\n      const playerIndexMap = new Map();\n      if (history.ticks[0] && history.ticks[0].players) {\n        history.ticks[0].players.forEach((player, index) => {\n          playerIndexMap.set(player.id, index);\n        });\n      }\n\n      const tileColors = {\n        AIR: \"lightgray\", // Empty\n        WALL: \"gray\", // Wall\n        BOX: \"sandybrown\", // Box\n      };\n\n      function drawField(field) {\n        for (let y = 0; y < fieldHeight; y++) {\n          for (let x = 0; x < fieldWidth; x++) {\n            const tile = field[y * fieldWidth + x];\n            const destX = x * tileWidth;\n            const destY = y * tileHeight;\n            const baseSpriteWidth = 32;\n            const baseSpriteHeight = 32;\n\n            // Always draw floor first\n            ctx.drawImage(\n              textureAtlas,\n              64, // floor sx\n              0, // floor sy\n              baseSpriteWidth,\n              baseSpriteHeight,\n              destX,\n              destY,\n              tileWidth,\n              tileHeight,\n            );\n\n            if (tile === \"WALL\") {\n              const hasWallUp =\n                y > 0 && field[(y - 1) * fieldWidth + x] === \"WALL\";\n              const hasWallDown =\n                y < fieldHeight - 1 &&\n                field[(y + 1) * fieldWidth + x] === \"WALL\";\n              const hasWallLeft =\n                x > 0 && field[y * fieldWidth + (x - 1)] === \"WALL\";\n              const hasWallRight =\n                x < fieldWidth - 1 &&\n                field[y * fieldWidth + (x + 1)] === \"WALL\";\n\n              let sx = 0;\n              const sy = 32; // Wall sprites are in the second row\n\n              // The logic to select the correct wall sprite based on neighbors.\n              // Bitmask: 8 (Up), 4 (Down), 2 (Left), 1 (Right)\n              const neighbors =\n                (hasWallUp << 3) |\n                (hasWallDown << 2) |\n                (hasWallLeft << 1) |\n                hasWallRight;\n\n              switch (neighbors) {\n                case 0: // No neighbors: solitary wall\n                  sx = 192;\n                  break;\n                case 1: // Right only\n                case 2: // Left only\n                case 3: // Left and Right: horizontal wall\n                  sx = 0;\n                  break;\n                case 4: // Down only\n                case 8: // Up only\n                case 12: // Up and Down: vertical wall\n                  sx = 32;\n                  break;\n                case 5: // Down and Right: corner ╔\n                  sx = 64;\n                  break;\n                case 6: // Down and Left: corner ╗\n                  sx = 96;\n                  break;\n                case 9: // Up and Right: corner ╚\n                  sx = 128;\n                  break;\n                case 10: // Up and Left: corner ╝\n                  sx = 160;\n                  break;\n                default:\n                  // T-junctions and Crosses\n                  if (neighbors & 3) {\n                    // Has Left or Right, prioritize horizontal\n                    sx = 0;\n                  } else {\n                    // Must be a T-junction pointing left/right, use vertical\n                    sx = 32;\n                  }\n                  break;\n              }\n\n              ctx.drawImage(\n                textureAtlas,\n                sx,\n                sy,\n                baseSpriteWidth,\n                baseSpriteHeight,\n                destX,\n                destY,\n                tileWidth,\n                tileHeight,\n              );\n            } else if (tile === \"BOX\") {\n              ctx.drawImage(\n                textureAtlas,\n                32, // sx\n                0, // sy\n                baseSpriteWidth,\n                baseSpriteHeight,\n                destX,\n                destY,\n                tileWidth,\n                tileHeight,\n              );\n            }\n            // For AIR tiles, the floor is already drawn, so do nothing else.\n          }\n        }\n      }\n\n      function drawPlayers(players) {\n        const MAX_LIVES = 3;\n        const HEART_SPRITE_WIDTH = 16;\n        const HEART_SPRITE_HEIGHT = 16;\n        const FULL_HEART_SX = 96;\n        const EMPTY_HEART_SX = 112;\n        const HEARTS_SY = 0;\n        const SPRITE_WIDTH = 32;\n\n        players.forEach((player) => {\n          // Determine player state\n          let state = \"IDLE\";\n          if (player.health === 0) {\n            state = \"DEAD\";\n          } else if (currentTick > 0) {\n            const prevTick = history.ticks[currentTick - 1];\n            const prevPlayer = prevTick.players.find((p) => p.id === player.id);\n            if (prevPlayer) {\n              if (player.pos.x > prevPlayer.pos.x) state = \"RIGHT\";\n              else if (player.pos.x < prevPlayer.pos.x) state = \"LEFT\";\n              else if (player.pos.y > prevPlayer.pos.y) state = \"DOWN\";\n              else if (player.pos.y < prevPlayer.pos.y) state = \"UP\";\n            }\n          }\n\n          // Determine sprite coordinates\n          const playerIndex = playerIndexMap.get(player.id) || 0;\n          const sy = playerIndex === 0 ? 96 : 192;\n          let baseSx = 0;\n          switch (state) {\n            case \"DOWN\":\n              baseSx = 0;\n              break;\n            case \"LEFT\":\n              baseSx = 3 * SPRITE_WIDTH;\n              break;\n            case \"RIGHT\":\n              baseSx = 6 * SPRITE_WIDTH;\n              break;\n            case \"UP\":\n              baseSx = 9 * SPRITE_WIDTH;\n              break;\n            case \"DEAD\":\n              baseSx = 12 * SPRITE_WIDTH;\n              break;\n            case \"IDLE\":\n            default:\n              baseSx = 0;\n              break;\n          }\n\n          const sx =\n            state === \"IDLE\" ? baseSx : baseSx + animationFrame * SPRITE_WIDTH;\n\n          // Draw Player Sprite\n          ctx.drawImage(\n            textureAtlas,\n            sx,\n            sy,\n            SPRITE_WIDTH,\n            SPRITE_WIDTH, // Assuming square sprites\n            player.pos.x * tileWidth,\n            player.pos.y * tileHeight,\n            tileWidth,\n            tileHeight,\n          );\n\n          const lives = player.health !== undefined ? player.health : MAX_LIVES;\n          if (lives > 0) {\n            const heartRenderWidth = tileWidth / 2.5;\n            const heartRenderHeight = tileHeight / 2.5;\n            const totalHeartsWidth = MAX_LIVES * heartRenderWidth;\n            const startX =\n              player.pos.x * tileWidth + tileWidth / 2 - totalHeartsWidth / 2;\n            const startY = player.pos.y * tileHeight - heartRenderHeight * 1.1; // Place slightly above the tile\n\n            for (let i = 0; i < MAX_LIVES; i++) {\n              const isFull = i < lives;\n              const heartSx = isFull ? FULL_HEART_SX : EMPTY_HEART_SX;\n\n              ctx.drawImage(\n                textureAtlas,\n                heartSx,\n                HEARTS_SY,\n                HEART_SPRITE_WIDTH,\n                HEART_SPRITE_HEIGHT,\n                startX + i * heartRenderWidth,\n                startY,\n                heartRenderWidth,\n                heartRenderHeight,\n              );\n            }\n          }\n        });\n      }\n\n      function getPlayerById(id) {\n        // Find the player with the given id in the first tick\n        const firstTick = history.ticks[0];\n        return firstTick.players.find((p) => p.id === id);\n      }\n\n      let animationFrame = 0;\n      const FRAME_COUNT = 3;\n      const SPRITE_WIDTH = 32;\n\n      function drawBombs(bombs) {\n        const sx = animationFrame * SPRITE_WIDTH;\n        const sy = 64;\n\n        bombs.forEach((bomb) => {\n          ctx.drawImage(\n            textureAtlas,\n            sx,\n            sy,\n            SPRITE_WIDTH,\n            SPRITE_WIDTH,\n            bomb.pos.x * tileWidth,\n            bomb.pos.y * tileHeight,\n            tileWidth,\n            tileHeight,\n          );\n        });\n      }\n\n      function drawExplosions(explosions) {\n        if (!explosions || explosions.length === 0) {\n          return;\n        }\n        const explosionSet = new Set(\n          explosions.map((exp) => `${exp.x},${exp.y}`),\n        );\n\n        explosions.forEach((exp) => {\n          const hasUp = explosionSet.has(`${exp.x},${exp.y - 1}`);\n          const hasDown = explosionSet.has(`${exp.x},${exp.y + 1}`);\n          const hasLeft = explosionSet.has(`${exp.x - 1},${exp.y}`);\n          const hasRight = explosionSet.has(`${exp.x + 1},${exp.y}`);\n\n          // Bitmask: 8 (U), 4 (D), 2 (L), 1 (R)\n          const neighbors =\n            (hasUp << 3) | (hasDown << 2) | (hasLeft << 1) | hasRight;\n\n          let baseSx = 0;\n          let sy = 0;\n\n          switch (neighbors) {\n            // End-caps\n            case 1: // Right only\n              baseSx = 0;\n              sy = 13 * 32;\n              break;\n            case 2: // Left only\n              baseSx = 0;\n              sy = 11 * 32;\n              break;\n            case 4: // Down only\n              baseSx = 0;\n              sy = 10 * 32;\n              break;\n            case 8: // Up only\n              baseSx = 0;\n              sy = 12 * 32;\n              break;\n\n            // Straight pieces\n            case 3: // Left-Right\n              baseSx = 0;\n              sy = 9 * 32;\n              break;\n            case 12: // Up-Down\n              baseSx = 0;\n              sy = 8 * 32;\n              break; // Fallback to cross\n\n            // Corners\n            case 6: // Down-Left\n              baseSx = 96;\n              sy = 7 * 32;\n              break;\n            case 5: // Down-Right\n              baseSx = 96;\n              sy = 10 * 32;\n              break;\n            case 10: // Up-Left\n              baseSx = 96;\n              sy = 8 * 32;\n              break;\n            case 9: // Up-Right\n              baseSx = 96;\n              sy = 9 * 32;\n              break;\n\n            // T-Junctions\n            case 7: // Down-Left-Right\n              baseSx = 96;\n              sy = 14 * 32;\n              break;\n            case 11: // Up-Left-Right\n              baseSx = 96;\n              sy = 12 * 32;\n              break;\n            case 13: // Up-Down-Right\n              baseSx = 96;\n              sy = 13 * 32;\n              break;\n            case 14: // Up-Down-Left\n              baseSx = 96;\n              sy = 11 * 32;\n              break;\n\n            // Cross and default\n            case 15: // All directions\n            default:\n              baseSx = 0;\n              sy = 7 * 32;\n              break;\n          }\n\n          const sx = baseSx + animationFrame * SPRITE_WIDTH;\n          ctx.drawImage(\n            textureAtlas,\n            sx,\n            sy,\n            SPRITE_WIDTH,\n            SPRITE_WIDTH,\n            exp.x * tileWidth,\n            exp.y * tileHeight,\n            tileWidth,\n            tileHeight,\n          );\n        });\n      }\n\n      function drawDestroyedBoxes(boxes, field) {\n        boxes.forEach((box) => {\n          field[box.y * fieldWidth + box.x] = \" \";\n        });\n      }\n\n      function renderTick(tickIndex, isNewTick = true) {\n        if (isNewTick) {\n          currentTick = tickIndex;\n        }\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        const tick = history.ticks[tickIndex];\n        if (!tick) return;\n\n        // Rebuild field state up to the current tick\n        let field = [...history.initial_field.field];\n        for (let i = 0; i <= tickIndex; i++) {\n          const pastTick = history.ticks[i];\n          if (pastTick.destroyed_boxes) {\n            drawDestroyedBoxes(pastTick.destroyed_boxes, field);\n          }\n        }\n\n        drawField(field);\n        drawPlayers(tick.players);\n        drawBombs(tick.bombs);\n        drawExplosions(tick.explosions);\n\n        tickCounter.textContent = `Tick: ${tickIndex} / ${totalTicks}`;\n      }\n\n      prevBtn.addEventListener(\"click\", () => {\n        if (currentTick > 0) {\n          renderTick(currentTick - 1);\n        }\n      });\n\n      nextBtn.addEventListener(\"click\", () => {\n        if (currentTick < totalTicks) {\n          renderTick(currentTick + 1);\n        }\n      });\n\n      let lastFrameTime = 0;\n      const ANIMATION_INTERVAL = 200; // ms per frame\n\n      function animationLoop(currentTime) {\n        const deltaTime = currentTime - lastFrameTime;\n\n        if (deltaTime > ANIMATION_INTERVAL) {\n          lastFrameTime = currentTime;\n          animationFrame = (animationFrame + 1) % FRAME_COUNT;\n          // Re-render the current tick without changing it\n          renderTick(currentTick, false);\n        }\n\n        requestAnimationFrame(animationLoop);\n      }\n\n      // Initial render\n      textureAtlas.onload = () => {\n        renderTick(0);\n        requestAnimationFrame(animationLoop);\n      };\n    </script>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			return nil
		})
		templ_7745c5c3_Err = layout.Base(csrf, user).Render(templ.WithChildren(ctx, templ_7745c5c3_Var2), templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
